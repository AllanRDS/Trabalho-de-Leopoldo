<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Music Player</title>
</head>
<body>
    <audio id="bgAudio" loop></audio>
    <script>
        const audio = document.getElementById('bgAudio');
        
        // Gerar áudio
        async function generateMusic() {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const sampleRate = audioContext.sampleRate;
            const duration = 12;
            const audioBuffer = audioContext.createBuffer(1, sampleRate * duration, sampleRate);
            const channelData = audioBuffer.getChannelData(0);

            // Melodia
            const melody = [
                {freq: 523.25, start: 0, duration: 0.4},
                {freq: 659.25, start: 0.5, duration: 0.4},
                {freq: 523.25, start: 1.0, duration: 0.4},
                {freq: 392.00, start: 1.5, duration: 0.8},
                {freq: 440.00, start: 3, duration: 0.4},
                {freq: 523.25, start: 3.5, duration: 0.4},
                {freq: 440.00, start: 4.0, duration: 0.4},
                {freq: 329.63, start: 4.5, duration: 0.8},
                {freq: 349.23, start: 6, duration: 0.4},
                {freq: 440.00, start: 6.5, duration: 0.4},
                {freq: 523.25, start: 7.0, duration: 0.4},
                {freq: 440.00, start: 7.5, duration: 0.8},
                {freq: 392.00, start: 9, duration: 0.4},
                {freq: 493.88, start: 9.5, duration: 0.4},
                {freq: 392.00, start: 10.0, duration: 0.4},
                {freq: 293.66, start: 10.5, duration: 1.0}
            ];

            const pad = [
                {freq: 130.81, start: 0, duration: 12},
                {freq: 164.81, start: 0, duration: 12},
                {freq: 196.00, start: 0, duration: 12}
            ];

            // Gerar pad
            pad.forEach(note => {
                for (let i = 0; i < channelData.length; i++) {
                    const t = i / sampleRate;
                    const fadeTime = sampleRate * 1.5;
                    let envelope = 0.04;
                    if (i < fadeTime) envelope *= i / fadeTime;
                    else if (i > channelData.length - fadeTime) envelope *= (channelData.length - i) / fadeTime;
                    channelData[i] += Math.sin(2 * Math.PI * note.freq * t) * envelope;
                }
            });

            // Gerar melodia
            melody.forEach(note => {
                const startSample = Math.floor(note.start * sampleRate);
                const durationSamples = Math.floor(note.duration * sampleRate);
                const attackSamples = Math.floor(0.05 * sampleRate);
                const releaseSamples = Math.floor(0.2 * sampleRate);
                for (let i = 0; i < durationSamples; i++) {
                    const sampleIndex = startSample + i;
                    if (sampleIndex < channelData.length) {
                        const t = i / sampleRate;
                        let envelope = 0.18;
                        if (i < attackSamples) envelope *= i / attackSamples;
                        else if (i > durationSamples - releaseSamples) envelope *= (durationSamples - i) / releaseSamples;
                        channelData[sampleIndex] += Math.sin(2 * Math.PI * note.freq * t) * envelope;
                    }
                }
            });

            // Converter para WAV
            const wavData = encodeWAV(audioBuffer);
            const blob = new Blob([wavData], { type: 'audio/wav' });
            return URL.createObjectURL(blob);
        }

        function encodeWAV(audioBuffer) {
            const numChannels = audioBuffer.numberOfChannels;
            const sampleRate = audioBuffer.sampleRate;
            const format = 1;
            const bitDepth = 16;
            const bytesPerSample = bitDepth / 8;
            const blockAlign = numChannels * bytesPerSample;
            const data = audioBuffer.getChannelData(0);
            const dataLength = data.length * bytesPerSample;
            const buffer = new ArrayBuffer(44 + dataLength);
            const view = new DataView(buffer);
            
            function writeString(view, offset, string) {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            }
            
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataLength, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, format, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * blockAlign, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitDepth, true);
            writeString(view, 36, 'data');
            view.setUint32(40, dataLength, true);
            
            let offset = 44;
            for (let i = 0; i < data.length; i++) {
                const sample = Math.max(-1, Math.min(1, data[i]));
                view.setInt16(offset, sample * 0x7FFF, true);
                offset += 2;
            }
            return buffer;
        }

        // API para controlar
        window.startMusic = async function() {
            const url = await generateMusic();
            audio.src = url;
            audio.volume = 0.4;
            await audio.play();
            console.log('Música iniciada no iframe');
        };

        window.stopMusic = function() {
            audio.pause();
            console.log('Música pausada no iframe');
        };

        window.isPlaying = function() {
            return !audio.paused;
        };
    </script>
</body>
</html>
